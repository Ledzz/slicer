class LayerRegion {
  layer() {
    return this._layer;
  }
  region(): PrintRegion {
    return this._region;
  }

  /// Collection of surfaces generated by slicing the original geometry
  /// Divided by type top/bottom/internal
  slices: SurfaceCollection;

  /// Collection of extrusion paths/loops filling gaps
  thin_fills: ExtrusionEntityCollection;

  /// Collection of surfaces for infill generation
  fill_surfaces: SurfaceCollection;

  /// Collection of expolygons representing the bridged areas (thus not
  /// needing support material)
  bridged: Polygons;

  /// Collection of polylines representing the unsupported bridge edges
  unsupported_bridge_edges: PolylineCollection;

  /// Ordered collection of extrusion paths/loops to build all perimeters
  /// (this collection contains only ExtrusionEntityCollection objects)
  perimeters: ExtrusionEntityCollection;

  /// Ordered collection of extrusion paths to fill surfaces
  /// (this collection contains only ExtrusionEntityCollection objects)
  fills: ExtrusionEntityCollection;

  /// Flow object which provides methods to predict material spacing.
  flow(role: FlowRole, bridge = false, width = -1): Flow {}
  /// Merges this->slices
  merge_slices();
  /// Preprocesses fill surfaces
  prepare_fill_surfaces();
  /// Generates and stores the perimeters and thin fills
  make_perimeters(slices: SurfaceCollection, fill_surfaces: SurfaceCollection);
  /// Generate infills for a LayerRegion.
  make_fill();
  /// Processes external surfaces for bridges and top/bottom surfaces
  process_external_surfaces();
  /// Gets the smallest fillable area
  infill_area_threshold(): number;

  /// Pointer to associated Layer
  private _layer: Layer;
  /// Pointer to associated PrintRegion
  private _region: PrintRegion;
  /// Mutex object for slices.
  // mutable boost::mutex _slices_mutex;

  ///Constructor
  // LayerRegion(Layer *layer, PrintRegion *region)
  // : _layer(layer), _region(region) {};
  constructor(layer: Layer, region: PrintRegion) {
    this._layer = layer;
    this._region = region;
  }
}

export class Layer {
  /// ID number
  id(): number;
  /// Setter for this->_id
  set_id(id: number);
  /// Getter for _object
  object() {
    return this._object;
  }

  upper_layer: Layer; ///< Pointer to layer above
  lower_layer: Layer; ///< Pointer to layer below
  regions: LayerRegionPtrs; ///< Vector of pointers to the LayerRegions of this layer
  slicing_errors: boolean; ///< Presence of slicing errors
  slice_z: number; ///< Z used for slicing in unscaled coordinates
  print_z: number; ///< Z used for printing in unscaled coordinates
  height: number; ///< layer height in unscaled coordinates

  slices: ExPolygonCollection; ///< collection of expolygons generated by slicing the original geometry;
  ///< also known as 'islands' (all regions and surface types are merged here)

  /// Returns the number of regions
  region_count(): number;
  /// Gets a region at a specific id
  get_region(idx: number) {
    return this.regions[idx];
  }
  /// Gets a region at a specific id as const
  get_region(idx: number) {
    return this.regions[idx];
  }

  /// Adds a PrintRegion
  add_region(print_region: PrintRegion): LayerRegion;
  /// Merge all regions' slices to get islands
  make_slices();
  /// Merges all of the LayerRegions' slices
  merge_slices();
  /// Template which iterates over all of the LayerRegion for internally containing the argument
  // template <class T> bool any_internal_region_slice_contains(const T &item) const;
  /// Template which iterates over all of the LayerRegion for containing on the bottom the argument
  // template <class T> bool any_bottom_region_slice_contains(const T &item) const;
  /// Creates the perimeters cummulatively for all layer regions sharing the same parameters influencing the perimeters.
  make_perimeters();
  /// Makes fills for all the LayerRegion
  make_fills();
  /// Determines the type of surface (top/bottombridge/bottom/internal) each region is
  detect_surfaces_type();
  /// Processes the external surfaces
  process_external_surfaces();

  /// polymorphic id
  is_support() {
    return false;
  }

  protected _id: number; ///< sequential number of layer, 0-based
  _object: PrintObject; ///< Associated PrintObject

  /// Constructor
  constructor(
    id: number,
    object: PrintObject,
    height: number,
    print_z: number,
    slice_z: number,
  ) {}

  /// Deletes all regions
  clear_regions();
  /// Deletes a specific region
  delete_region(idx: number);
}

export class SupportLayer extends Layer {
  /// Collection of support islands.
  /// Populated in SupportMaterial.pm in sub generate_toolpaths
  support_islands: ExPolygonCollection;
  /// Collection of support fills.
  /// Populated in SupportMaterial.pm in sub generate_toolpaths
  support_fills: ExtrusionEntityCollection;
  /// Collection of support interface fills.
  /// Populated in SupportMaterial.pm in sub generate_toolpaths
  support_interface_fills: ExtrusionEntityCollection;

  /// polymorphic id
  is_support() {
    return true;
  }

  constructor(
    id: number,
    object: PrintObject,
    height: number,
    print_z: number,
    slice_z: number,
  ) {}
}
